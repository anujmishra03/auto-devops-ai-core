export const runtime = "nodejs";

import axios from "axios";
import Groq from "groq-sdk";

const groq = new Groq({
  apiKey: process.env.GROQ_API_KEY,
});

// normalize repo input → owner/name
function extractRepoName(input) {
  let repo = input.trim();
  if (repo.includes("github.com")) repo = repo.split("github.com/")[1];
  repo = repo.replace(/^\/+|\/+$/g, "").replace(".git", "");
  return repo;
}

// branch naming must match create-pr logic
function getBranchName(next_action) {
  return "autodevops-" + next_action.toLowerCase().replace(/\s+/g, "-");
}

export async function POST(req) {
  try {
    const { repo, token, next_action } = await req.json();

    if (!repo || !token || !next_action) {
      return Response.json(
        { ok: false, error: "repo, token & next_action required" },
        { status: 200 }
      );
    }

    const repoName = extractRepoName(repo);

    // 1) get default branch (for fallback if README missing on PR branch)
    const repoInfo = await axios.get(
      `https://api.github.com/repos/${repoName}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );
    const baseBranch = repoInfo.data.default_branch || "main";

    const branchName = getBranchName(next_action);
    const readmePath = "README.md";

    // 2) Try to read README from PR branch
    let existingContent = "";
    let existingSha = null;

    async function getReadme(refBranch) {
      const res = await axios.get(
        `https://api.github.com/repos/${repoName}/contents/${readmePath}`,
        {
          headers: { Authorization: `Bearer ${token}` },
          params: { ref: refBranch },
        }
      );
      return res.data;
    }

    try {
      const fileData = await getReadme(branchName);
      existingSha = fileData.sha;
      existingContent = Buffer.from(fileData.content, "base64").toString("utf8");
    } catch (err) {
      const status = err.response?.status;
      // If README not found on PR branch, try base branch
      if (status === 404) {
        try {
          const baseFileData = await getReadme(baseBranch);
          existingSha = baseFileData.sha;
          existingContent = Buffer.from(baseFileData.content, "base64").toString(
            "utf8"
          );
        } catch (err2) {
          // No README at all → start from empty template
          existingContent = `# ${repoName}\n\nProject README (generated by AutoDevOps AI)\n`;
          existingSha = null;
        }
      } else {
        throw err;
      }
    }

    // 3) Ask Groq to improve README based on next_action
    const prompt = `
You are AutoDevOps AI. Improve the following README.md content for a GitHub project.

- Make it clearer, more structured, and more professional.
- Add sections like: Overview, Features, Tech Stack, Getting Started, Future Improvements.
- Mention that the project uses an AI DevOps assistant that can scan the repo, open issues, and create PRs.
- Keep it in clean Markdown format only.
- Do not add any extra commentary outside the README content.

Current README:
---
${existingContent}
---
`;

    const chat = await groq.chat.completions.create({
      model: "llama-3.1-8b-instant",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.4,
    });

    const newReadme = chat.choices[0].message.content || existingContent;

    // 4) Commit updated README back to the PR branch
    const putBody = {
      message: "AutoDevOpsAI: Improve README via AI",
      content: Buffer.from(newReadme).toString("base64"),
      branch: branchName,
    };

    // If file existed, include sha; if not, GitHub will treat as new file
    if (existingSha) {
      putBody.sha = existingSha;
    }

    const commitRes = await axios.put(
      `https://api.github.com/repos/${repoName}/contents/${readmePath}`,
      putBody,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    return Response.json(
      {
        ok: true,
        file: readmePath,
        branch: branchName,
        commit_url: commitRes.data.commit?.html_url || null,
      },
      { status: 200 }
    );
  } catch (err) {
    const status = err.response?.status || 500;
    const msg = err.response?.data?.message || err.message;

    console.error("❌ Auto-fix README error:", status, msg);

    return Response.json(
      {
        ok: false,
        error: "Failed to auto-fix README",
        github_message: msg,
        status,
      },
      { status: 200 }
    );
  }
}
